LINUX CHEAT SHEET
============LIST ALL DRIVES CONNECTED TO COMPUTER ==============
 df -h

=============UBUNTU RESTORE DESKTOP====

export DISPLAY=:0
ccsm    # enable unity if disabled

sudo rm -rf ~/config
sudo rm -rf ~/compiz
sudo restart lightdm

=============PROCESSES==============

sudo pkil -9 -f processname   # -9 is kill signal -f full name search 
pgrep -f processname   # will show you what pkill will kill 

===========UBUNTU SPECIFIC===========

sudo vim /usr/share/gnome/applications/defaults.list #change default applications

============SCP======================

send  to  someone with verbosity (upload)

scp -v /local/path/tofile username@10.0.0.123:~/path/to/destination/in/home/dir

download file from remote connection

scp username@10.0.0.123:/path/to/file.txt /local/path/to/destination

You can automatically figure out where you're logged in from by checking the environment variables SSH_CONNECTION and/or SSH_CLIENT. SSH_CONNECTION for example shows the client address, the outgoing port on the client, the server address and the incoming port on the server. See section ENVIRONMENT in man ssh

So, if you want to copy a file from the server to the client from which you're logged in from, the following (which infers the client ip by taking the first part of SSH_CONNECTION) should work:

scp /path/to/file $(echo $SSH_CONNECTION | cut -f 1 -d ' '):/local/path/to/file


Copy the file "foobar.txt" from a remote host to the local host

$ scp your_username@remotehost.edu:foobar.txt /some/local/directory

Copy the file "foobar.txt" from the local host to a remote host

$ scp foobar.txt your_username@remotehost.edu:/some/remote/directory

Copy the directory "foo" from the local host to a remote host's directory "bar"

$ scp -r foo your_username@remotehost.edu:/some/remote/directory/bar

Copy the file "foobar.txt" from remote host "rh1.edu" to remote host "rh2.edu"

$ scp your_username@rh1.edu:/some/remote/directory/foobar.txt your_username@rh2.edu:/some/remote/directory/

Copying the files "foo.txt" and "bar.txt" from the local host to your home directory on the remote host

$ scp foo.txt bar.txt your_username@remotehost.edu:~

Copy the file "foobar.txt" from the local host to a remote host using port 2264

$ scp -P 2264 foobar.txt your_username@remotehost.edu:/some/remote/directory

Copy multiple files from the remote host to your current directory on the local host

$ scp your_username@remotehost.edu:/some/remote/directory/\{a,b,c\}

$ scp your_username@remotehost.edu:~/\{foo.txt,bar.txt\}


=============LOGINS==================

stay as root				sudo su
log in using ident			-i -u username
Log out					CTRL-D  OR exit
create a new user			adduser username


===========directories=============


rm filename	//removes files

By default, rm does not remove directories. If the -r (--recursive) option is specified, however, rm will remove any matching directories and their contents.

rm -i *

Attempt to remove every file in the working directory, but prompt before each file to confirm.

rm *           //no prompt unless file is write protected


==============users===========

usermod -l newUsername oldUsername

This however, doesn't rename the home folder.

To change home-folder, use

usermod -d /home/newHomeDir -m newUsername

====================SYSTEM======================

sudo vim /etc/gnome/defaults.list	#change default programs


===================FIND================================

-------------- Find Files Using Name-----------------

This is a basic usage of the find command. This example finds all files with name — MyCProgram.c in the current directory and all its sub-directories.

# find -name "MyCProgram.c"

------------ Inverting the match.-------------------

Shows the files or directories whose name are not MyCProgram.c .Since the maxdepth is 1, this will look only under current directory.

# find -maxdepth 1 -not -iname "MyCProgram.c



--------------------- Find Files Based on file-type using option -type-----------------

Find only the socket files.

# find . -type s

Find all directories

# find . -type d

Find only the normal files

# find . -type f

Find all the hidden files

# find . -type f -name ".*"

Find all the hidden directories

# find -type d -name ".*"


------------------Regex ------------------------------------------

Remember that the expression needs to match the whole path, i.e. needs to look like:

 find . -regex '\./[a-f0-9-]*.jpg'

------------------Limit Search To Specific Directory Level Using mindepth and maxdepth--------------------

Find the passwd file under all sub-directories starting from root directory.

# find / -name passwd

Find the passwd file under root and one level down. (i.e root — level 1, and one sub-directory — level 2)

# find -maxdepth 2 -name passwd


Find the passwd file under root and two levels down. (i.e root — level 1, and two sub-directories — level 2 and 3 )

# find / -maxdepth 3 -name passwd


Find the password file between sub-directory level 2 and 4.

# find -mindepth 3 -maxdepth 5 -name passwd


------------------Executing Commands on the Files Found by the Find Command----------------

You can specify inode number on a find command as shown below. In this example, find command renames a file using the inode number.
***** always place the \; escape sequence

# find -iname current_file_name.txt -exec mv {} new_test_file_name.txt \;



========== GREP ==================
Global Regular ExPression search

options
-i case insensitive
-r recursive into subdirectories
-n display line numbers where string is found
-w If you want to search for a word, and to avoid it to match the substrings 
-v invert match
-l print only names of FILEs containing matches | use it if you are piping grep results to another program


# Search for the given string in a single file
grep "literal_string" filename

# Search for the given string in a single file case insensitive
grep -i "literal_string" filename


# Search for the given string in all files
grep "literal_string" *

# Search for the given string in all files recursive into subdirectories
grep -r "literal_string" *

# Search for the given string in all files recursive into subdirectories case insensitive 
grep -ir "literal_string" *

# Checking for the given string in multiple files eg we have file_1.txt file_2.txt file_3.ini
grep "literal_string" file_*

--------------regex---------------

Syntax:
grep "REGEX" filename

grep "lines.*empty" demo_file


-------------search and replace-----

# first search using grep and then pass those search results to sed which searches through them and replaces
# string1 with string2
grep -rl matchstring somedir/ | xargs sed -i 's/string1/string2/g'


==============SED================
Stream EDitor

-----------substitute-------

# changing "day" in the "old" file to "night" in the "new" file, 
# the 'new' file will be created and the 'old' file remains untouched
sed s/day/night/ old >new

#This replaces it in the current file
sed s/day/night/ old

# test SED expressions in the terminal using echo
echo 'this is a day' | sed s/day/night/ 

#test multiline global replacement 
echo 'this is a day \\n this is also a day' | sed s/day/night/g 









